<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400;600;800&amp;display=swap" rel="stylesheet">
    <!--<link rel="icon" href="./favicon.ico" type="image/x-icon"> -->
    <title>Hello World</title>
  </head>

  <body>
    
  <nav class="navbar">
  <div class="util__center navbar__content">
    <a href="../index.html">
      <h1 class="navbar__logo">ZTalk</h1>
      <div class="navbar__logo-underline"></div>
    </a>
  </div>
</nav>

  <main>
    <div class="blog__container">
  <h1>Typescript Pattern Matching</h1>

  <h2>XXX</h2>

  <div class="blog__published-date">January 12, 2023</div>

  
      <p>
        Pattern matching is one of the more powerful tools available to
        programmers. It's something that I first ran across when learning
        Haskell, and then later Rust. At this point I'm not sure if I could be
        as productive in a language that doesn't support the feature.
      </p>

      <p>
        The general idea is that we can create a control-flow that exhaustively
        maps from a data shape to an expression or value. That's basically word
        vomit so let's break that down.
      </p>

      <p>
        <i>Control-flow:</i> Pattern matching is something like an
        <code class="blog__code">if/else</code>.
      </p>

      <p>
        <i>Exhaustively maps:</i> It's a mapping, so we can express this
        statement as a Typescript object. The <i>exhaustive</i> part is a little
        more complex, but it has to do with the object's keys. This is one of
        the most important concepts so we'll talk about this property in detail
        soon.
      </p>

      <p>
        <i>[Maps] from a data shape to an expression or value:</i> This means
        that the data's Type determines the Typescript object's keys, and thus
        what we are allowed to "match" on. The values are an expression or some
        value.
      </p>

      <p>
        I know things may still be fuzzy but hang in there - I promise this will
        make sense! With this we at least know that we can express a
        pattern-matching statement as an object in Typescript. Let's dive into a
        basic example to get our feet wet.
      </p>

      <pre class="code"><code>
  <span class="declaration">const</span> <span class="var-name">patternMatchBool</span> = {
    <span class="declaration">true</span>: <span class="string">"It's true"</span>,
    <span class="declaration">false</span>: <span class="string">"It's false"</span>
  };
  <span class="declaration">const</span> <span class="var-name">myBool</span> = true;
  <span class="declaration">const</span> <span class="var-name">matched</span> = <span class="var-name">patternMatchBool</span>[<span class="var-name">myBool</span>]; <span class="comment">// "It's true"</span>

</code></pre>

      <p>
        That doesn't look so bad! And it's all we need to do for some basic
        matching.
      </p>

      <p>
        But wait, couldn't this be expressed as a
        <code class="blog__code">switch</code> or
        <code class="blog__code">if/else</code>? In short, yes, it could be.
        Like I mentioned, pattern matching is just another control-flow
        statement and so it can often be used interchangably with the other more
        familiar statements. And honestly, between you and me, in this simple
        example it would be preferrable to do something like:
      </p>

      <pre class="code"><code>
  <span class="declaration">const</span> <span class="var-name">matched</span> = <span class="var-name">myBool</span>
    ? <span class="string">"It's true"</span>
    : <span class="string">"It's false"</span>;

</code></pre>

      <p>
        You're smart and you know it's coming so let's expand on the example.
        Instead of just booleans what if we're dealing with a set of known
        values - an Enum in Typescript. We know this is where
        <code class="blog__code">if/else</code> begins to fall short and there's
        entire books about how to avoid such travesties. Let's see how our
        pattern matching can start to handle such situations:
      </p>

      <pre class="code"><code>
  <span class="declaration">enum</span> <span class="var-name">Food</span> {
    <span class="declaration">Pizza</span>,
    <span class="declaration">Burrito</span>,
    <span class="declaration">Burger</span>,
  };
  <span class="declaration">const</span> <span class="var-name">FOOD_MATCHER</span> = {
    <span class="declaration">[</span>Food.Pizza<span class="declaration">]</span>: <span class="string">"Pizza party"</span>,
    <span class="declaration">[</span>Food.Burrito<span class="declaration">]</span>: <span class="string">"Burritos every weekend"</span>,
    <span class="declaration">[</span>Food.Burger<span class="declaration">]</span>: <span class="string">"Double patties"</span>,
  };
  <span class="declaration">const</span> <span class="var-name">myFood</span> = <span class="var-name">Food.Burrito</span>;
  <span class="declaration">const</span> <span class="var-name">matched</span> = <span class="var-name">FOOD_MATCHER</span>[<span class="var-name">myFood</span>]; <span class="comment">// "Burritos every weekend"</span>

</code></pre>
    
</div>
  </main>

  

</body></html>